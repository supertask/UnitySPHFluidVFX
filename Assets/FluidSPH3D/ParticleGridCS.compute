#pragma kernel ObjectToGridIndex
#pragma kernel ClearGridIndex
#pragma kernel BuildGridIndex
#pragma kernel BuildSortedObject

#pragma kernel UpdateColor
#pragma kernel ResetColor


#define SIMULATION_BLOCK_SIZE 128
#define GRID_BLOCK_SIZE 8
#include "CommonData.cginc"
#include "GridHelper.cginc"

StructuredBuffer<Particle> _ObjectBufferRead;
int	_ObjectBufferReadCount;
RWStructuredBuffer<Particle> _ObjectBufferSorted;

StructuredBuffer<uint2>	_ObjectGridIndexBufferRead;
RWStructuredBuffer<uint2> _ObjectGridIndexBufferWrite;

StructuredBuffer<uint2>	_GridBufferRead;
RWStructuredBuffer<uint2> _GridBufferWrite;


[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void ObjectToGridIndex(uint3 DTid : SV_DispatchThreadID) 
{
	const unsigned int P_ID = DTid.x;	// Particle ID to operate on

	float3 position = _ObjectBufferRead[P_ID].pos;
	_ObjectGridIndexBufferWrite[P_ID] = PosToGridIndexPair(P_ID, position, _GridMin, _GridMax, _GridSize, _GridSpacing);
}

[numthreads(GRID_BLOCK_SIZE, GRID_BLOCK_SIZE, GRID_BLOCK_SIZE)]
void ClearGridIndex(uint3 DTid : SV_DispatchThreadID) 
{
	uint C_ID = CellIndexToCellID(DTid, _GridSize);
	_GridBufferWrite[C_ID] = uint2(0, 0);
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void BuildGridIndex(uint3 DTid : SV_DispatchThreadID) 
{
	const unsigned int G_ID = DTid.x;	// Grid Data ID to operate on
	unsigned int       G_ID_PREV = (G_ID == 0) ? (uint)_ObjectBufferReadCount : G_ID; G_ID_PREV--;
	unsigned int       G_ID_NEXT = G_ID + 1; if (G_ID_NEXT == (uint)_ObjectBufferReadCount) { G_ID_NEXT = 0; }

	unsigned int cell = _ObjectGridIndexBufferRead[G_ID].x;
	unsigned int cell_prev = _ObjectGridIndexBufferRead[G_ID_PREV].x;
	unsigned int cell_next = _ObjectGridIndexBufferRead[G_ID_NEXT].x;

	if (cell != cell_prev) {
		// I'm the start of a cell
		_GridBufferWrite[cell].x = G_ID;
	}

	if (cell != cell_next) {
		// I'm the end of a cell
		_GridBufferWrite[cell].y = G_ID + 1;
	}
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void BuildSortedObject(uint3 DTid : SV_DispatchThreadID)
{
	const unsigned int ID = DTid.x; // Grid Data ID to operate on
	const unsigned int O_ID = _ObjectGridIndexBufferRead[ID].y;
	_ObjectBufferSorted[ID] = _ObjectBufferRead[O_ID];
}


float3 _TargetPos;
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void ResetColor(uint3 DTid : SV_DispatchThreadID)
{
	const unsigned int ID = DTid.x; // Particle ID to operate on
	_ObjectBufferSorted[ID].col = 1;
	// _ParticleBufferSorted[ID].pos = 0;
}

[numthreads(1, 1, 1)]
void UpdateColor(uint3 DTid : SV_DispatchThreadID)
{
	float3 pos = _TargetPos;
	pos.x = 0.2f;

	float3 cellPos = PosToCellPos(pos, _GridMin, _GridMax, _GridSpacing);
	int3 cid = CellPosToCellIndex(cellPos);

	int range = 8;

	for(int i = max(cid.x-range, 0); i <= min(cid.x+range, _GridSize.x-1); ++i)
	{
		for(int j = max(cid.y-range, 0); j <= min(cid.y+range, _GridSize.y-1); ++j)
		{
			for(int k = max(cid.z-range, 0); k <= min(cid.z+range, _GridSize.z-1); ++k)
			{
				uint2 startEnd = _GridBufferRead[CellIndexToCellID(int3(i,j,k), _GridSize)];
				for(uint id = startEnd.x; id < startEnd.y; ++id)
				{
					_ObjectBufferSorted[id].col = float4(1,0,0,1);
				}
			}
		}
	}
}