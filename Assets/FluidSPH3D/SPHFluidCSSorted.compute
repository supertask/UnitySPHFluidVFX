#pragma kernel Density
#pragma kernel Vorticity
#pragma kernel Viscosity
#pragma kernel Pressure
#pragma kernel Integrate

#pragma kernel InitIndexPool
#pragma kernel Emit

#pragma kernel AddBoundary

#define SIMULATION_BLOCK_SIZE 256

#include "SPHData.cginc"
#include "Kernel.cginc"
#include "GridHelper.cginc"

float _H;
float2 _PressureK;// k1 and k2 in State Equation Pressure
float _RestDensity;
float _ParticleMass;
float _Viscosity;
float _Vorticity;
float3 _Gravity;
float _TimeStep;

RWStructuredBuffer<Particle> _ParticleBuffer;
int _ParticleBufferCount;
StructuredBuffer<Particle> _ParticleBufferSorted;

RWStructuredBuffer<ParticleVelocity> _ParticleVelocityBuffer;
RWStructuredBuffer<ParticleDensity> _ParticleDensityBuffer;
RWStructuredBuffer<ParticleForce>  _ParticleForceBuffer;
RWStructuredBuffer<ParticleVorticity>  _ParticleVorticityBuffer;
RWStructuredBuffer<int>  _ParticleCount;

StructuredBuffer<uint2> _GridBuffer;

#include "SPHIndexPool.cginc"

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Density(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
	const unsigned int P_ID = DTid.x;
	Particle p = _ParticleBufferSorted[P_ID];
	if(!IsActive(p)) return;

	float3 P_position = p.pos;

	float density = 0.0;

    int3 cid = PosToCellIndex(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 range = 1;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		int3 index = int3(i,j,k);
		if(!IsCellIndexValid(index, _GridSize)) continue;

		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint N_ID = startEnd.x; N_ID < startEnd.y; ++N_ID)
		{
			Particle np = _ParticleBufferSorted[N_ID];
			if(!IsActive(np)) continue;

			float3 N_position = np.pos;

			float gamma = IsBoundary(np)?20:1;

			float3 r = P_position - N_position;
			density += _ParticleMass * W(r, _H) * gamma;
		}
	}
	_ParticleDensityBuffer[P_ID].density = max(density, _RestDensity);
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Vorticity(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
	const unsigned int P_ID = DTid.x; // Particle ID to operate on

	Particle p = _ParticleBufferSorted[P_ID];
	if(!IsActive(p)) return;

	float3 P_position = _ParticleBufferSorted[P_ID].pos;
	float3 P_velocity = _ParticleBufferSorted[P_ID].vel;
	float  P_density  = _ParticleDensityBuffer[P_ID].density;

	const float h_sq = pow(_H, 2);
	float3 w = 0;
	
    int3 cid = PosToCellIndex(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 range = 1;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		int3 index = int3(i,j,k);
		if(!IsCellIndexValid(index, _GridSize)) continue;

		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint N_ID = startEnd.x; N_ID < startEnd.y; ++N_ID)
		{
			Particle np = _ParticleBufferSorted[N_ID];
			if(!IsActive(np)) continue;

			float3 N_position = _ParticleBufferSorted[N_ID].pos;

			float3 r = P_position - N_position;
			float r_sq = dot(r, r);
			if (r_sq < h_sq && P_ID != N_ID)
			{
				float3 N_velocity = _ParticleBufferSorted[N_ID].vel;
				float  N_density = _ParticleDensityBuffer[N_ID].density;

				float3 r = P_position - N_position;

				float3 gradW = WGrad(r, _H);
				w += -_ParticleMass/N_density *(cross(P_velocity - N_velocity, gradW));
			}
		}
	}
	
	_ParticleVorticityBuffer[P_ID].vor = w;
	AllMemoryBarrier();

	float3 n = 0;
	LOOP_RANGE(i1, j1, k1, cid, range, _GridSize)
	{
		int3 index = int3(i1,j1,k1);
		if(!IsCellIndexValid(index, _GridSize)) continue;

		uint2 startEnd = _GridBuffer[CellIndexToCellID(index, _GridSize)];
		for(uint N_ID = startEnd.x; N_ID < startEnd.y; ++N_ID)
		{
			Particle np = _ParticleBufferSorted[N_ID];
			if(!IsActive(np)) continue;

			float3 N_position = _ParticleBufferSorted[N_ID].pos;

			float3 r = P_position - N_position;
			float r_sq = dot(r, r);
			if (r_sq < h_sq && P_ID != N_ID)
			{
				float3 N_velocity = _ParticleBufferSorted[N_ID].vel;
				float  N_density = _ParticleDensityBuffer[N_ID].density;
				float3 N_vorticity = _ParticleVorticityBuffer[N_ID].vor;

				float3 r = P_position - N_position;

				float3 gradW = WGrad(r, _H);
				n += _ParticleMass/N_density * length(N_vorticity) * gradW;
			}
		}
	}
	float3 force = 0;
	if(length(n) > 0)
	{
		float ep = _Vorticity;
		force += ep * cross(normalize(n), w);
	}

	_ParticleForceBuffer[P_ID].force = force;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Viscosity(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
	const unsigned int P_ID = DTid.x; // Particle ID to operate on

	Particle p = _ParticleBufferSorted[P_ID];
	if(!IsActive(p)) return;

	float3 P_position = _ParticleBufferSorted[P_ID].pos;
	float3 P_velocity = _ParticleBufferSorted[P_ID].vel;
	float  P_density  = _ParticleDensityBuffer[P_ID].density;

	const float h_sq = pow(_H, 2);

	float3 force = _ParticleForceBuffer[P_ID].force;
	
    int3 cid = PosToCellIndex(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 range = 1;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		int3 index = int3(i,j,k);
		if(!IsCellIndexValid(index, _GridSize)) continue;

		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint N_ID = startEnd.x; N_ID < startEnd.y; ++N_ID)
		{
			Particle np = _ParticleBufferSorted[N_ID];
			if(!IsActive(np)) continue;

			float3 N_position = _ParticleBufferSorted[N_ID].pos;

			float3 r = P_position - N_position;
			float r_sq = dot(r, r);
			if (r_sq < h_sq && P_ID != N_ID)
			{
				float3 N_velocity = _ParticleBufferSorted[N_ID].vel;
				float  N_density = _ParticleDensityBuffer[N_ID].density;

				// Viscosity Term
				force += CalculateLapVelocity(_H, _ParticleMass, _Viscosity, r, P_velocity, N_velocity, P_density, N_density);
				float3 r = P_position - N_position;
				// force += _ParticleMass/N_density *(N_velocity - P_velocity) * W(r, _H);

			}
		}
	}
	// P_velocity + _TimeStep * (force) / _ParticleMass;

	// float alpha = 2.0f;
	// P_velocity += alpha * force;

	// force = 0;
	// if(distance(P_position, float3(0.1,0.3,0)) < 0.2 * 5) force += normalize(P_position-float3(0.1,0.3,0)) * 500;
	// if(distance(P_position, float3(0.8 * 5,0.1,0)) < 0.2 * 5) force += normalize(P_position-float3(0.8 * 5,0.1,0)) * 500;
	// if(distance(P_position, float3(-0.5 * 5,0.5 * 10,0)) < 0.4 * 5) force += normalize(P_position-float3(-0.4 * 5,0.5 * 10,0)) * 500;
	// if(distance(P_position, float3(0.1,0.3,0)) < 0.2) force += normalize(P_position-float3(0.1,0.3,0)) * 500;
	// if(distance(P_position, float3(0.8 ,0.1,0)) < 0.2) force += normalize(P_position-float3(0.8,0.1,0)) * 500;
	// if(distance(P_position, float3(-0.5,0.5 ,0)) < 0.4 ) force += normalize(P_position-float3(-0.4,0.5,0)) * 500;
	// force += (sdBox(P_position, float3(0.5,0.5,0.1)) < 0)?float3(0,100,0):0;

	_ParticleVelocityBuffer[P_ID].vel= P_velocity + _TimeStep * (force + _Gravity) / _ParticleMass;
}


[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Pressure(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
	const unsigned int P_ID = DTid.x; // Particle ID to operate on
	
	Particle p = _ParticleBufferSorted[P_ID];
	if(!IsActive(p)) return;

	float3 P_position = _ParticleBufferSorted[P_ID].pos;
	float3 P_velocity = _ParticleBufferSorted[P_ID].vel;
	float  P_density  = _ParticleDensityBuffer[P_ID].density;
	float  P_pressure = CalculateSEPressure(P_density, _PressureK.x, _PressureK.y, _RestDensity);

	const float h_sq = pow(_H, 2);

	float3 gradPressure = float3(0, 0, 0);
	int count = 0;

	
    int3 cid = PosToCellIndex(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 range = 1;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		int3 index = int3(i,j,k);
		if(!IsCellIndexValid(index, _GridSize)) continue;
		
		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint N_ID = startEnd.x; N_ID < startEnd.y; ++N_ID)
		{
			Particle np = _ParticleBufferSorted[N_ID];
			if(!IsActive(np)) continue;

			float3 N_position = _ParticleBufferSorted[N_ID].pos;

			float3 r = P_position - N_position;
			float r_sq = dot(r, r);
			if (r_sq < h_sq && P_ID != N_ID)
			{
				float3 N_velocity = _ParticleBufferSorted[N_ID].vel;
				float  N_density = _ParticleDensityBuffer[N_ID].density;
				float  N_pressure = CalculateSEPressure(N_density, _PressureK.x, _PressureK.y, _RestDensity);

				gradPressure += CalculateGradPressure(_H, _ParticleMass, r, P_pressure, N_pressure, P_density, N_density);
				count++;
			}
		}
	}

	_ParticleForceBuffer[P_ID].force = -(1.0/P_density) * P_density *  gradPressure;
	_ParticleCount[P_ID] = count;
}

//--------------------------------------------------------------------------------------
// Integration
//--------------------------------------------------------------------------------------
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Integrate(uint3 Gid  : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint  GI : SV_GroupIndex) {
	const unsigned int P_ID = DTid.x; // Particle ID to operate on

	Particle p = _ParticleBufferSorted[P_ID];
	if(IsActive(p))
	{
		float3 acceleration = _ParticleForceBuffer[P_ID].force;
		float3 velocity = _ParticleVelocityBuffer[P_ID].vel;

		if(p.type == PT_FLUID)
		{
			p.vel = velocity + _TimeStep * acceleration / _ParticleMass;
			p.pos += _TimeStep * p.vel;
		}
		else
		{
		}

		float3 gmin = _GridMin;
		float3 gmax = _GridMax;

		float scale = 0.1f;
		if (p.pos.x < gmin.x) {
			p.vel.x = -p.vel.x * scale;
			p.pos.x = gmin.x;
		}
		if (p.pos.x > gmax.x) {
			p.vel.x = -p.vel.x * scale;
			p.pos.x = gmax.x;
		}
		if (p.pos.y < gmin.y) {
			p.vel.y = 0;
			p.pos.y = gmin.y;
			// p.vel.xy = float2(p.vel.x * 0.1,-0.1f);
			// p.pos.y = gmax.y - _GridSpacing.y;
		}
		if (p.pos.y > gmax.y) {
			p.vel.y = 0;
			p.pos.y = gmax.y;
		}

		if (p.pos.z > gmax.z) {
			p.vel.z = -p.vel.z * scale;
			p.pos.z = gmax.z;
		}
		if (p.pos.z < gmin.z) {
			p.vel.z = -p.vel.z * scale;
			p.pos.z = gmin.z;

			if(p.pos.y < gmin.y + _GridSpacing.y * 5)
			{
			// p.vel.xy = float2(p.vel.x * 0.1,-0.1f);
			// p.vel.z = 0;
			// p.pos.y = gmax.y - _GridSpacing.y;
			// p.pos.z = gmax.z - _GridSpacing.z * 20;
			}
		}
	}
	// Update
	_ParticleBuffer[P_ID] = p;
}
