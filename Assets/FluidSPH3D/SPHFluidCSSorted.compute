#pragma kernel Density
#pragma kernel Force
#pragma kernel Integrate

#include "SPHData.cginc"
#include "GridHelper.cginc"
#define SIMULATION_BLOCK_SIZE 256

float _Smoothlen;
int   _SearchRange;
float _PressureStiffness;
float _RestDensity;
// float _ParticleMass; //Not used
// float _Viscosity; //Not used
float3 _Gravity;
float _TimeStep;

//Runtime parameter
float _DensityCoef;
float _GradPressureCoef;
float _LapViscosityCoef;

RWStructuredBuffer<Particle> _ParticleBuffer;
RWStructuredBuffer<Particle> _ParticleBufferSorted;

RWStructuredBuffer<ParticleDensity> _ParticleDensityBuffer;
RWStructuredBuffer<ParticleForce>  _ParticleForceBuffer;

StructuredBuffer<uint2> _GridBuffer;

float CalculateDensity(float r_sq) {
	const float h_sq = _Smoothlen * _Smoothlen;
	// Implements this equation:
	// W_poly6(r, h) = 315 / (64 * pi * h^9) * (h^2 - r^2)^3
	// g_fDensityCoef = fParticleMass * 315.0f / (64.0f * PI * fSmoothlen^9)
	return _DensityCoef * (h_sq - r_sq) * (h_sq - r_sq) * (h_sq - r_sq);
}
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Density(uint3 Gid  : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint  GI : SV_GroupIndex) {
	const unsigned int P_ID = DTid.x;
	const float h_sq = _Smoothlen * _Smoothlen;
	float3 P_position = _ParticleBufferSorted[P_ID].pos;

	float density = 0;

	// Calculate the density based on neighbors from the 8 adjacent cells + current cell
	float3 cellPos = PosToCellPos(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 cid = CellPosToCellIndex(cellPos);

	int3 range = _SearchRange;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint id = startEnd.x; id < startEnd.y; ++id)
		{
			float3 N_position = _ParticleBufferSorted[id].pos;

			float3 diff = N_position - P_position;
			float r_sq = dot(diff, diff);
			if (0 < r_sq && r_sq < h_sq && P_ID != id) {
			// if (r_sq < h_sq) {
				density += CalculateDensity(r_sq);
			}
		}
	}

	_ParticleDensityBuffer[P_ID].density = max(density, _RestDensity);
	// _ParticleDensityBuffer[P_ID].density = clamp(max(density, _RestDensity), 0, 10 * _RestDensity);
	// _ParticleDensityBuffer[P_ID].density = density;
}


//--------------------------------------------------------------------------------------
// Force Calculation
//--------------------------------------------------------------------------------------

float CalculatePressure(float density) {
	// Implements this equation:
	// Pressure = B * ((rho / rho_0)^y  - 1)
	return _PressureStiffness * max(pow(density / _RestDensity, 3) - 1, 0);
}

float3 CalculateGradPressure(float r, float P_pressure, float N_pressure, float N_density, float3 diff) {
	const float h = _Smoothlen;
	float avg_pressure = 0.5f * (N_pressure + P_pressure);
	// Implements this equation:
	// W_spkiey(r, h) = 15 / (pi * h^6) * (h - r)^3
	// GRAD( W_spikey(r, h) ) = -45 / (pi * h^6) * (h - r)^2
	// g_fGradPressureCoef = fParticleMass * -45.0f / (PI * fSmoothlen^6)
	return _GradPressureCoef * avg_pressure / N_density * (h - r) * (h - r) / r * (diff);
}

float3 CalculateLapVelocity(float r, float3 P_velocity, float3 N_velocity, float N_density) {
	const float h = _Smoothlen;
	float3 vel_diff = (N_velocity - P_velocity);
	// Implements this equation:
	// W_viscosity(r, h) = 15 / (2 * pi * h^3) * (-r^3 / (2 * h^3) + r^2 / h^2 + h / (2 * r) - 1)
	// LAPLACIAN( W_viscosity(r, h) ) = 45 / (pi * h^6) * (h - r)
	// g_fLapViscosityCoef = fParticleMass * fViscosity * 45.0f / (PI * fSmoothlen^6)
	return _LapViscosityCoef / N_density * (h - r) * vel_diff;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Force(uint3 Gid  : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint  GI : SV_GroupIndex) {
	const unsigned int P_ID = DTid.x; // Particle ID to operate on

	float3 P_position = _ParticleBufferSorted[P_ID].pos;
	float3 P_velocity = _ParticleBufferSorted[P_ID].vel;
	float  P_density = _ParticleDensityBuffer[P_ID].density;
	float  P_pressure = CalculatePressure(P_density);

	const float h_sq = _Smoothlen * _Smoothlen;

	float3 acceleration = float3(0, 0, 0);

	// Calculate the acceleration based on neighbors from the 8 adjacent cells + current cell
	float3 cellPos = PosToCellPos(P_position, _GridMin, _GridMax, _GridSpacing);
	int3 cid = CellPosToCellIndex(cellPos);
	int3 range = _SearchRange;
	LOOP_RANGE(i, j, k, cid, range, _GridSize)
	{
		uint2 startEnd = _GridBuffer[CellIndexToCellID(int3(i,j,k), _GridSize)];
		for(uint id = startEnd.x; id < startEnd.y; ++id)
		{
			float3 N_position = _ParticleBufferSorted[id].pos;

			float3 diff = N_position - P_position;
			float r_sq = dot(diff, diff);
			if (0 < r_sq && r_sq < h_sq && P_ID != id) {
				float3 N_velocity = _ParticleBufferSorted[id].vel;
				float  N_density = _ParticleDensityBuffer[id].density;
				float  N_pressure = CalculatePressure(N_density);
				float  r = sqrt(r_sq);

				// Pressure Term
				acceleration += CalculateGradPressure(r, P_pressure, N_pressure, N_density, diff);

				// Viscosity Term
				acceleration += CalculateLapVelocity(r, P_velocity, N_velocity, N_density);
			}
		}
	}

	_ParticleForceBuffer[P_ID].force = acceleration / P_density;
}

//--------------------------------------------------------------------------------------
// Integration
//--------------------------------------------------------------------------------------

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Integrate(uint3 Gid  : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint  GI : SV_GroupIndex) {
	const unsigned int P_ID = DTid.x; // Particle ID to operate on

	Particle p = _ParticleBufferSorted[P_ID];
	float3 acceleration = _ParticleForceBuffer[P_ID].force;

	// Apply gravity
	acceleration += _Gravity.xyz;

	p.vel+= _TimeStep * acceleration;
	p.pos+= _TimeStep * p.vel;

	float3 offset = 0;//_GridSpacing * 1.001f;
	float3 gmin = _GridMin + offset;
	float3 gmax = _GridMax - offset;

	if (p.pos.x < gmin.x) {
		p.vel.x = 0;
		p.pos.x = gmin.x;
	}
	if (p.pos.x > gmax.x) {
		p.vel.x = 0;
		p.pos.x = gmax.x;
	}
	if (p.pos.y < gmin.y) {
		p.vel.y = 0;
		p.pos.y = gmin.y;
	}
	if (p.pos.y > gmax.y) {
		p.vel.y = 0;
		p.pos.y = gmax.y;
	}

	if (p.pos.z < gmin.z) {
		p.vel.z = 0;
		p.pos.z = gmin.z;
	}
	if (p.pos.z > gmax.z) {
		p.vel.z = 0;
		p.pos.z = gmax.z;
	}
	// Update
	_ParticleBuffer[P_ID] = p;
}